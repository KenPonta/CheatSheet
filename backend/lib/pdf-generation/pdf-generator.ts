import puppeteer, { Browser, Page } from 'puppeteer'
import { 
  GenerationRequest, 
  GenerationResult, 
  ContentWarning, 
  ContentFitAnalysis,
  PDFGenerationOptions,
  CheatSheetTopic,
  PageBreakStrategy,
  PrintOptimizationOptions
} from './types'
import { CheatSheetTemplates } from './templates'

export class PDFGenerator {
  private browser: Browser | null = null

  async initialize(): Promise<void> {
    if (!this.browser) {
      this.browser = await puppeteer.launch({
        headless: true,
        args: [
          '--no-sandbox',
          '--disable-setuid-sandbox',
          '--disable-dev-shm-usage',
          '--disable-gpu',
          '--no-first-run',
          '--no-zygote',
          '--single-process'
        ]
      })
    }
  }

  async cleanup(): Promise<void> {
    if (this.browser) {
      await this.browser.close()
      this.browser = null
    }
  }

  private generatePDFOptions(request: GenerationRequest): PDFGenerationOptions {
    const { config } = request
    
    const formatMap = {
      a4: 'A4' as const,
      letter: 'Letter' as const,
      legal: 'Legal' as const,
      a3: 'A3' as const
    }

    // Enhanced margins for better print quality
    const margins = this.calculateOptimalMargins(config.paperSize, config.orientation)
    
    return {
      format: formatMap[config.paperSize] || 'A4',
      landscape: config.orientation === 'landscape',
      margin: margins,
      printBackground: true,
      displayHeaderFooter: config.includeHeaders !== false || config.includeFooters !== false,
      headerTemplate: this.generateHeaderTemplate(request),
      footerTemplate: this.generateFooterTemplate(request),
      preferCSSPageSize: true,
      // Enhanced PDF generation options
      tagged: true, // For accessibility
      outline: false, // Disable outline for smaller file size
      width: undefined, // Let CSS handle sizing
      height: undefined,
      pageRanges: '', // Generate all pages
      omitBackground: false, // Include background for better visual quality
      timeout: 60000 // Increased timeout for complex documents
    }
  }

  private calculateOptimalMargins(paperSize: string, orientation: string) {
    // Optimized margins for different paper sizes and orientations
    const baseMargins = {
      a4: { top: '15mm', right: '12mm', bottom: '15mm', left: '12mm' },
      letter: { top: '0.6in', right: '0.5in', bottom: '0.6in', left: '0.5in' },
      legal: { top: '0.6in', right: '0.5in', bottom: '0.6in', left: '0.5in' },
      a3: { top: '20mm', right: '15mm', bottom: '20mm', left: '15mm' }
    }

    const margins = baseMargins[paperSize as keyof typeof baseMargins] || baseMargins.a4

    // Adjust margins for landscape orientation
    if (orientation === 'landscape') {
      return {
        top: margins.left,
        right: margins.top,
        bottom: margins.right,
        left: margins.bottom
      }
    }

    return margins
  }

  private generateHeaderTemplate(request: GenerationRequest): string {
    if (request.config.includeHeaders === false) return ''
    
    const title = request.title || 'Study Cheat Sheet'
    const subtitle = request.subtitle ? ` - ${request.subtitle}` : ''
    
    return `
      <div style="
        font-family: Arial, sans-serif;
        font-size: 8px;
        color: #666;
        text-align: center;
        width: 100%;
        padding: 0 10mm;
        margin-top: 5mm;
        border-bottom: 1px solid #e5e7eb;
        padding-bottom: 2mm;
      ">
        <span style="font-weight: bold;">${title}</span>${subtitle}
        <span style="float: right; font-size: 7px;">${new Date().toLocaleDateString()}</span>
      </div>
    `
  }

  private generateFooterTemplate(request: GenerationRequest): string {
    if (request.config.includeFooters === false) return ''
    
    return `
      <div style="
        font-family: Arial, sans-serif;
        font-size: 8px;
        color: #666;
        text-align: center;
        width: 100%;
        padding: 0 10mm;
        margin-bottom: 5mm;
        border-top: 1px solid #e5e7eb;
        padding-top: 2mm;
        display: flex;
        justify-content: space-between;
        align-items: center;
      ">
        <span style="font-size: 7px;">Generated by CheatSheet Creator</span>
        <span>Page <span class="pageNumber"></span> of <span class="totalPages"></span></span>
        <span style="font-size: 7px;">Â© ${new Date().getFullYear()}</span>
      </div>
    `
  }

  private analyzeContentFit(
    topics: CheatSheetTopic[],
    pageCount: number,
    config: any
  ): ContentFitAnalysis {
    // Estimate content size based on character count and images
    const totalCharacters = topics.reduce((sum, topic) => {
      const content = topic.customContent || topic.content
      return sum + content.length + topic.topic.length
    }, 0)

    const totalImages = topics.reduce((sum, topic) => {
      return sum + (topic.images?.length || 0)
    }, 0)

    // Rough estimation: 2000 characters per page for small font, 1500 for medium, 1200 for large
    const charsPerPage = config.fontSize === 'small' ? 2000 : config.fontSize === 'medium' ? 1500 : 1200
    const imagesPerPage = 2 // Rough estimate

    const estimatedPagesFromText = Math.ceil(totalCharacters / charsPerPage)
    const estimatedPagesFromImages = Math.ceil(totalImages / imagesPerPage)
    const estimatedPages = Math.max(estimatedPagesFromText, estimatedPagesFromImages)

    const contentUtilization = pageCount > 0 ? Math.min(estimatedPages / pageCount, 1) : 0
    const overflowContent = Math.max(0, estimatedPages - pageCount)

    return {
      totalContent: totalCharacters + totalImages * 500, // Treat each image as 500 chars
      fittedContent: Math.min(totalCharacters, charsPerPage * pageCount),
      overflowContent,
      estimatedPages,
      contentUtilization
    }
  }

  private generateWarnings(
    contentFit: ContentFitAnalysis,
    topics: CheatSheetTopic[],
    config: any
  ): ContentWarning[] {
    const warnings: ContentWarning[] = []

    // Content overflow warning
    if (contentFit.overflowContent > 0) {
      warnings.push({
        type: 'overflow',
        severity: contentFit.overflowContent > contentFit.totalContent * 0.3 ? 'high' : 'medium',
        message: `Content may not fit in ${config.pageCount || 'specified'} pages. Estimated ${contentFit.estimatedPages} pages needed.`,
        affectedContent: topics.slice(-Math.ceil(contentFit.overflowContent / 500)).map(t => t.topic),
        suggestions: [
          'Increase page count',
          'Reduce content in selected topics',
          'Use smaller font size',
          'Remove some images'
        ]
      })
    }

    // Image quality warnings
    const recreatedImages = topics.flatMap(t => t.images?.filter(img => img.isRecreated) || [])
    if (recreatedImages.length > 0) {
      warnings.push({
        type: 'quality',
        severity: 'low',
        message: `${recreatedImages.length} images were recreated using AI and may differ from originals.`,
        affectedContent: recreatedImages.map(img => img.alt),
        suggestions: [
          'Review recreated images for accuracy',
          'Replace with original images if available'
        ]
      })
    }

    // Layout warnings for too many columns
    if (config.columns > 2 && config.fontSize === 'large') {
      warnings.push({
        type: 'layout',
        severity: 'medium',
        message: 'Large font size with multiple columns may cause readability issues.',
        affectedContent: ['Layout configuration'],
        suggestions: [
          'Reduce number of columns',
          'Use smaller font size',
          'Switch to portrait orientation'
        ]
      })
    }

    return warnings
  }

  async generatePDF(request: GenerationRequest): Promise<GenerationResult> {
    try {
      await this.initialize()
      
      if (!this.browser) {
        throw new Error('Failed to initialize browser')
      }

      // Apply print optimizations to the request
      const optimizedRequest = await this.applyPrintOptimizations(request)

      // Generate HTML with enhanced page break handling
      const html = CheatSheetTemplates.generateHTML(
        optimizedRequest.topics,
        optimizedRequest.config,
        optimizedRequest.title,
        optimizedRequest.subtitle,
        optimizedRequest.referenceText
      )

      // Create page and set content
      const page = await this.browser.newPage()
      
      // Set optimal viewport for PDF generation
      const viewport = this.calculateOptimalViewport(request.config)
      await page.setViewport(viewport)
      
      // Enable print media emulation early
      await page.emulateMediaType('print')
      
      // Set content with enhanced loading strategy
      await page.setContent(html, { 
        waitUntil: ['networkidle0', 'domcontentloaded'],
        timeout: 60000
      })

      // Enhanced image loading with error handling
      await this.waitForImagesWithFallback(page)

      // Apply page break optimizations
      await this.optimizePageBreaks(page, request.config)

      // Generate PDF with enhanced options
      const pdfOptions = this.generatePDFOptions(optimizedRequest)
      const pdfBuffer = await page.pdf(pdfOptions)

      // Get accurate page count and content analysis
      const pageCount = await this.getAccuratePageCount(page)
      const contentFit = this.analyzeContentFit(optimizedRequest.topics, pageCount, optimizedRequest.config)
      
      // Generate comprehensive warnings
      const warnings = this.generateWarnings(contentFit, optimizedRequest.topics, optimizedRequest.config)

      // Validate PDF quality
      const qualityWarnings = await this.validatePDFQuality(pdfBuffer, optimizedRequest)
      warnings.push(...qualityWarnings)

      await page.close()

      return {
        html,
        pdf: pdfBuffer,
        warnings,
        pageCount,
        contentFit,
        success: true,
        metadata: {
          fileSize: pdfBuffer.length,
          generationTime: Date.now(),
          optimization: 'enhanced'
        }
      }

    } catch (error) {
      console.error('PDF generation error:', error)
      
      // Enhanced fallback with error analysis
      return await this.handleGenerationError(error, request)
    }
  }

  private async applyPrintOptimizations(request: GenerationRequest): Promise<GenerationRequest> {
    const optimizedConfig = { ...request.config }
    
    // Optimize column count for paper size and orientation
    if (optimizedConfig.paperSize === 'a4' && optimizedConfig.orientation === 'portrait' && optimizedConfig.columns > 2) {
      optimizedConfig.columns = 2 // Limit columns for better readability on A4 portrait
    }
    
    // Optimize font size for content density
    if (request.topics.length > 20 && optimizedConfig.fontSize === 'large') {
      optimizedConfig.fontSize = 'medium' // Reduce font size for dense content
    }
    
    return {
      ...request,
      config: optimizedConfig
    }
  }

  private calculateOptimalViewport(config: any) {
    const baseViewports = {
      a4: { width: 794, height: 1123 }, // A4 in pixels at 96 DPI
      letter: { width: 816, height: 1056 }, // Letter in pixels
      legal: { width: 816, height: 1344 }, // Legal in pixels
      a3: { width: 1123, height: 1587 } // A3 in pixels
    }
    
    const viewport = baseViewports[config.paperSize as keyof typeof baseViewports] || baseViewports.a4
    
    if (config.orientation === 'landscape') {
      return { width: viewport.height, height: viewport.width }
    }
    
    return viewport
  }

  private async waitForImagesWithFallback(page: Page): Promise<void> {
    try {
      await page.evaluate(() => {
        return Promise.all(
          Array.from(document.images, img => {
            if (img.complete) return Promise.resolve()
            return new Promise((resolve, reject) => {
              const timeout = setTimeout(() => {
                console.warn(`Image load timeout: ${img.src}`)
                resolve(undefined) // Don't fail on image timeout
              }, 10000)
              
              img.addEventListener('load', () => {
                clearTimeout(timeout)
                resolve(undefined)
              })
              img.addEventListener('error', () => {
                clearTimeout(timeout)
                console.warn(`Image load error: ${img.src}`)
                resolve(undefined) // Don't fail on image error
              })
            })
          })
        )
      })
    } catch (error) {
      console.warn('Image loading failed, continuing with PDF generation:', error)
    }
  }

  private async optimizePageBreaks(page: Page, config: any): Promise<void> {
    await page.evaluate((pageCount) => {
      // Add intelligent page break handling
      const topics = document.querySelectorAll('.topic-section')
      
      topics.forEach((topic, index) => {
        const topicElement = topic as HTMLElement
        const rect = topicElement.getBoundingClientRect()
        
        // Avoid orphaned content at page bottom
        if (rect.height > 100) { // Only for substantial content
          topicElement.style.pageBreakInside = 'avoid'
        }
        
        // Add page breaks for better distribution
        if (pageCount && pageCount > 1 && index > 0 && index % Math.ceil(topics.length / pageCount) === 0) {
          topicElement.style.pageBreakBefore = 'always'
        }
      })
      
      // Optimize image placement
      const images = document.querySelectorAll('.topic-image')
      images.forEach(img => {
        const imgElement = img as HTMLElement
        imgElement.style.pageBreakInside = 'avoid'
        imgElement.style.pageBreakAfter = 'avoid'
      })
      
    }, config.pageCount)
  }

  private async getAccuratePageCount(page: Page): Promise<number> {
    try {
      const pageCount = await page.evaluate(() => {
        // More accurate page count calculation
        const body = document.body
        const computedStyle = window.getComputedStyle(body)
        
        // Get page height from CSS or use default
        const pageHeight = parseFloat(computedStyle.getPropertyValue('--page-height')) || 
                          (document.documentElement.style.getPropertyValue('size')?.includes('297mm') ? 297 : 279) // A4 vs Letter
        
        // Calculate content height
        const contentHeight = Math.max(
          body.scrollHeight,
          body.offsetHeight,
          document.documentElement.clientHeight,
          document.documentElement.scrollHeight,
          document.documentElement.offsetHeight
        )
        
        // Convert mm to pixels (approximate)
        const pageHeightPx = (pageHeight / 25.4) * 96
        
        // Account for margins and headers/footers
        const effectivePageHeight = pageHeightPx * 0.85 // 15% for margins and headers
        
        return Math.max(1, Math.ceil(contentHeight / effectivePageHeight))
      })
      
      return pageCount
    } catch (error) {
      console.warn('Could not determine accurate page count:', error)
      return 1
    }
  }

  private async validatePDFQuality(pdfBuffer: Buffer, request: GenerationRequest): Promise<ContentWarning[]> {
    const warnings: ContentWarning[] = []
    
    // Check PDF file size
    const fileSizeMB = pdfBuffer.length / (1024 * 1024)
    if (fileSizeMB > 10) {
      warnings.push({
        type: 'quality',
        severity: 'medium',
        message: `PDF file size is large (${fileSizeMB.toFixed(1)}MB). Consider reducing image quality or content.`,
        affectedContent: ['PDF file size'],
        suggestions: ['Reduce image resolution', 'Remove unnecessary images', 'Split into multiple documents']
      })
    }
    
    // Check for potential rendering issues
    const hasComplexLayout = request.config.columns > 2 || request.topics.some(t => t.images && t.images.length > 3)
    if (hasComplexLayout) {
      warnings.push({
        type: 'quality',
        severity: 'low',
        message: 'Complex layout detected. Please verify PDF rendering quality.',
        affectedContent: ['Layout rendering'],
        suggestions: ['Preview PDF before printing', 'Consider simplifying layout', 'Test print on target printer']
      })
    }
    
    return warnings
  }

  private async handleGenerationError(error: any, request: GenerationRequest): Promise<GenerationResult> {
    console.error('PDF generation error:', error)
    
    // Generate fallback HTML
    const html = CheatSheetTemplates.generateHTML(
      request.topics,
      request.config,
      request.title,
      request.subtitle,
      request.referenceText
    )

    const contentFit = this.analyzeContentFit(request.topics, 1, request.config)
    const warnings = this.generateWarnings(contentFit, request.topics, request.config)
    
    // Add specific error information
    const errorMessage = error.message || 'Unknown error occurred'
    warnings.push({
      type: 'quality',
      severity: 'high',
      message: `PDF generation failed: ${errorMessage}. HTML version provided as fallback.`,
      affectedContent: ['PDF output'],
      suggestions: [
        'Try reducing content complexity',
        'Check image sources and formats',
        'Reduce page count or font size',
        'Try again with fewer images'
      ]
    })

    return {
      html,
      warnings,
      pageCount: 1,
      contentFit,
      success: false,
      metadata: {
        fileSize: 0,
        generationTime: Date.now(),
        optimization: 'fallback',
        error: errorMessage
      }
    }
  }

  private async getPageCount(page: Page): Promise<number> {
    try {
      // Use print media emulation to get accurate page count
      await page.emulateMediaType('print')
      
      const pageCount = await page.evaluate(() => {
        // Create a temporary element to measure content height
        const tempDiv = document.createElement('div')
        tempDiv.style.position = 'absolute'
        tempDiv.style.visibility = 'hidden'
        tempDiv.style.height = 'auto'
        tempDiv.style.width = '100%'
        tempDiv.innerHTML = document.body.innerHTML
        document.body.appendChild(tempDiv)
        
        const contentHeight = tempDiv.scrollHeight
        document.body.removeChild(tempDiv)
        
        // Get page height from CSS
        const style = getComputedStyle(document.documentElement)
        const pageHeight = parseFloat(style.getPropertyValue('--page-height')) || 297 // Default A4 height in mm
        
        // Convert to pixels (rough approximation)
        const pageHeightPx = (pageHeight / 25.4) * 96 // mm to px conversion
        
        return Math.ceil(contentHeight / pageHeightPx)
      })
      
      return Math.max(1, pageCount)
    } catch (error) {
      console.warn('Could not determine page count:', error)
      return 1
    }
  }

  async generateHTMLOnly(request: GenerationRequest): Promise<GenerationResult> {
    const html = CheatSheetTemplates.generateHTML(
      request.topics,
      request.config,
      request.title,
      request.subtitle,
      request.referenceText
    )

    const contentFit = this.analyzeContentFit(request.topics, request.config.pageCount || 1, request.config)
    const warnings = this.generateWarnings(contentFit, request.topics, request.config)

    return {
      html,
      warnings,
      pageCount: request.config.pageCount || 1,
      contentFit,
      success: true
    }
  }
}

// Singleton instance for reuse
export const pdfGenerator = new PDFGenerator()