import { PDFGenerator } from '../pdf-generator'
import { GenerationRequest, CheatSheetTopic, CheatSheetConfig } from '../types'
import puppeteer from 'puppeteer'

// Mock puppeteer
jest.mock('puppeteer')

describe('Enhanced PDF Generation Features', () => {
  let pdfGenerator: PDFGenerator
  let mockBrowser: any
  let mockPage: any

  beforeEach(() => {
    pdfGenerator = new PDFGenerator()
    
    mockPage = {
      setViewport: jest.fn(),
      setContent: jest.fn(),
      evaluate: jest.fn(),
      pdf: jest.fn().mockResolvedValue(Buffer.from('mock-pdf-content')),
      emulateMediaType: jest.fn(),
      close: jest.fn()
    }
    
    mockBrowser = {
      newPage: jest.fn().mockResolvedValue(mockPage),
      close: jest.fn()
    }
    
    ;(puppeteer.launch as jest.Mock).mockResolvedValue(mockBrowser)
  })

  afterEach(async () => {
    await pdfGenerator.cleanup()
    jest.clearAllMocks()
  })

  describe('Page Break Optimization', () => {
    const mockRequest: GenerationRequest = {
      topics: Array.from({ length: 10 }, (_, i) => ({
        id: `topic-${i}`,
        topic: `Topic ${i}`,
        content: `Content for topic ${i}`.repeat(10)
      })),
      config: {
        paperSize: 'a4',
        orientation: 'portrait',
        columns: 2,
        fontSize: 'medium',
        pageCount: 3
      },
      title: 'Test Cheat Sheet'
    }

    it('should apply intelligent page break optimizations', async () => {
      mockPage.evaluate
        .mockResolvedValueOnce(undefined) // image loading
        .mockResolvedValueOnce(undefined) // page break optimization
        .mockResolvedValueOnce(3) // accurate page count

      await pdfGenerator.generatePDF(mockRequest)

      // Should call page break optimization
      expect(mockPage.evaluate).toHaveBeenCalledWith(
        expect.any(Function),
        mockRequest.config.pageCount
      )
    })

    it('should handle orphan and widow prevention', async () => {
      mockPage.evaluate
        .mockResolvedValueOnce(undefined) // image loading
        .mockResolvedValueOnce(undefined) // page break optimization
        .mockResolvedValueOnce(2) // accurate page count

      const result = await pdfGenerator.generatePDF(mockRequest)

      expect(result.html).toContain('orphans: 2')
      expect(result.html).toContain('widows: 2')
      expect(result.html).toContain('page-break-inside: avoid')
    })
  })

  describe('Multi-page Support with Headers and Footers', () => {
    const mockRequest: GenerationRequest = {
      topics: [
        {
          id: 'topic-1',
          topic: 'Test Topic',
          content: 'Test content'
        }
      ],
      config: {
        paperSize: 'a4',
        orientation: 'portrait',
        columns: 1,
        fontSize: 'medium',
        includeHeaders: true,
        includeFooters: true
      },
      title: 'Multi-page Test',
      subtitle: 'With Headers and Footers'
    }

    it('should generate enhanced headers with title and date', async () => {
      mockPage.evaluate
        .mockResolvedValueOnce(undefined) // image loading
        .mockResolvedValueOnce(undefined) // page break optimization
        .mockResolvedValueOnce(2) // accurate page count

      await pdfGenerator.generatePDF(mockRequest)

      const pdfOptions = mockPage.pdf.mock.calls[0][0]
      expect(pdfOptions.headerTemplate).toContain('Multi-page Test')
      expect(pdfOptions.headerTemplate).toContain('With Headers and Footers')
      expect(pdfOptions.headerTemplate).toContain('border-bottom: 1px solid')
      expect(pdfOptions.headerTemplate).toContain(new Date().toLocaleDateString())
    })

    it('should generate enhanced footers with page numbers and branding', async () => {
      mockPage.evaluate
        .mockResolvedValueOnce(undefined) // image loading
        .mockResolvedValueOnce(undefined) // page break optimization
        .mockResolvedValueOnce(2) // accurate page count

      await pdfGenerator.generatePDF(mockRequest)

      const pdfOptions = mockPage.pdf.mock.calls[0][0]
      expect(pdfOptions.footerTemplate).toContain('pageNumber')
      expect(pdfOptions.footerTemplate).toContain('totalPages')
      expect(pdfOptions.footerTemplate).toContain('Generated by CheatSheet Creator')
      expect(pdfOptions.footerTemplate).toContain(new Date().getFullYear().toString())
    })

    it('should respect header and footer configuration', async () => {
      const requestWithoutHeaders = {
        ...mockRequest,
        config: {
          ...mockRequest.config,
          includeHeaders: false,
          includeFooters: false
        }
      }

      mockPage.evaluate
        .mockResolvedValueOnce(undefined) // image loading
        .mockResolvedValueOnce(undefined) // page break optimization
        .mockResolvedValueOnce(1) // accurate page count

      await pdfGenerator.generatePDF(requestWithoutHeaders)

      const pdfOptions = mockPage.pdf.mock.calls[0][0]
      expect(pdfOptions.headerTemplate).toBe('')
      expect(pdfOptions.footerTemplate).toBe('')
      expect(pdfOptions.displayHeaderFooter).toBe(false)
    })
  })

  describe('Enhanced Image Support', () => {
    const mockRequestWithImages: GenerationRequest = {
      topics: [
        {
          id: 'topic-1',
          topic: 'Topic with Images',
          content: 'Content with embedded images',
          images: [
            {
              id: 'img-1',
              src: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mP8/5+hHgAHggJ/PchI7wAAAABJRU5ErkJggg==',
              alt: 'Test image',
              caption: 'Test caption',
              width: 100,
              height: 100
            },
            {
              id: 'img-2',
              src: 'https://example.com/image.jpg',
              alt: 'External image',
              isRecreated: true
            }
          ]
        }
      ],
      config: {
        paperSize: 'a4',
        orientation: 'portrait',
        columns: 1,
        fontSize: 'medium'
      },
      title: 'Image Test'
    }

    it('should handle embedded images with proper optimization', async () => {
      mockPage.evaluate
        .mockResolvedValueOnce(undefined) // image loading
        .mockResolvedValueOnce(undefined) // page break optimization
        .mockResolvedValueOnce(1) // accurate page count

      const result = await pdfGenerator.generatePDF(mockRequestWithImages)

      expect(result.html).toContain('data:image/png;base64')
      expect(result.html).toContain('loading="eager"')
      expect(result.html).toContain('decoding="sync"')
      expect(result.html).toContain('page-break-inside: avoid')
    })

    it('should handle image loading errors gracefully', async () => {
      // Mock image loading to fail
      mockPage.evaluate
        .mockRejectedValueOnce(new Error('Image loading failed'))
        .mockResolvedValueOnce(undefined) // page break optimization
        .mockResolvedValueOnce(1) // accurate page count

      const result = await pdfGenerator.generatePDF(mockRequestWithImages)

      expect(result.success).toBe(true) // Should still succeed
      expect(result.html).toContain('onerror=')
    })

    it('should mark recreated images appropriately', async () => {
      mockPage.evaluate
        .mockResolvedValueOnce(undefined) // image loading
        .mockResolvedValueOnce(undefined) // page break optimization
        .mockResolvedValueOnce(1) // accurate page count

      const result = await pdfGenerator.generatePDF(mockRequestWithImages)

      expect(result.html).toContain('AI Generated')
      expect(result.html).toContain('recreated-badge')
    })
  })

  describe('Print-ready CSS with Exact Measurements', () => {
    it('should generate CSS with exact measurements for different paper sizes', async () => {
      const paperSizes = ['a4', 'letter', 'legal', 'a3'] as const

      for (const paperSize of paperSizes) {
        const request: GenerationRequest = {
          topics: [{ id: '1', topic: 'Test', content: 'Content' }],
          config: {
            paperSize,
            orientation: 'portrait',
            columns: 1,
            fontSize: 'medium'
          }
        }

        mockPage.evaluate
          .mockResolvedValueOnce(undefined) // image loading
          .mockResolvedValueOnce(undefined) // page break optimization
          .mockResolvedValueOnce(1) // accurate page count

        const result = await pdfGenerator.generatePDF(request)

        expect(result.html).toContain('--page-width:')
        expect(result.html).toContain('--page-height:')
        expect(result.html).toContain('--margin-top:')
        expect(result.html).toContain('size: var(--page-width) var(--page-height)')
      }
    })

    it('should include comprehensive print media queries', async () => {
      const request: GenerationRequest = {
        topics: [{ id: '1', topic: 'Test', content: 'Content' }],
        config: {
          paperSize: 'a4',
          orientation: 'portrait',
          columns: 2,
          fontSize: 'medium'
        }
      }

      mockPage.evaluate
        .mockResolvedValueOnce(undefined) // image loading
        .mockResolvedValueOnce(undefined) // page break optimization
        .mockResolvedValueOnce(1) // accurate page count

      const result = await pdfGenerator.generatePDF(request)

      expect(result.html).toContain('@media print')
      expect(result.html).toContain('print-color-adjust: exact !important')
      expect(result.html).toContain('-webkit-print-color-adjust: exact !important')
      expect(result.html).toContain('color-adjust: exact !important')
    })
  })

  describe('Content Preservation and Quality Validation', () => {
    it('should validate PDF quality and generate appropriate warnings', async () => {
      // Mock large PDF
      const largePdfBuffer = Buffer.alloc(12 * 1024 * 1024) // 12MB
      mockPage.pdf.mockResolvedValueOnce(largePdfBuffer)

      const complexRequest: GenerationRequest = {
        topics: [
          {
            id: 'topic-1',
            topic: 'Complex Topic',
            content: 'Content',
            images: Array.from({ length: 4 }, (_, i) => ({
              id: `img-${i}`,
              src: `test${i}.jpg`,
              alt: `Image ${i}`
            }))
          }
        ],
        config: {
          paperSize: 'a4',
          orientation: 'portrait',
          columns: 3,
          fontSize: 'medium'
        }
      }

      mockPage.evaluate
        .mockResolvedValueOnce(undefined) // image loading
        .mockResolvedValueOnce(undefined) // page break optimization
        .mockResolvedValueOnce(1) // accurate page count

      const result = await pdfGenerator.generatePDF(complexRequest)

      expect(result.warnings).toEqual(
        expect.arrayContaining([
          expect.objectContaining({
            type: 'quality',
            message: expect.stringContaining('PDF file size is large')
          }),
          expect.objectContaining({
            type: 'quality',
            message: expect.stringContaining('Complex layout detected')
          })
        ])
      )
    })

    it('should preserve content fidelity during PDF generation', async () => {
      const originalContent = 'Original content with special characters: áéíóú & <tags>'
      const request: GenerationRequest = {
        topics: [
          {
            id: 'topic-1',
            topic: 'Fidelity Test',
            content: originalContent
          }
        ],
        config: {
          paperSize: 'a4',
          orientation: 'portrait',
          columns: 1,
          fontSize: 'medium'
        }
      }

      mockPage.evaluate
        .mockResolvedValueOnce(undefined) // image loading
        .mockResolvedValueOnce(undefined) // page break optimization
        .mockResolvedValueOnce(1) // accurate page count

      const result = await pdfGenerator.generatePDF(request)

      expect(result.html).toContain(originalContent)
      expect(result.success).toBe(true)
    })
  })

  describe('Performance and Error Handling', () => {
    it('should handle timeout scenarios gracefully', async () => {
      mockPage.setContent.mockRejectedValueOnce(new Error('Timeout'))

      const request: GenerationRequest = {
        topics: [{ id: '1', topic: 'Test', content: 'Content' }],
        config: {
          paperSize: 'a4',
          orientation: 'portrait',
          columns: 1,
          fontSize: 'medium'
        }
      }

      const result = await pdfGenerator.generatePDF(request)

      expect(result.success).toBe(false)
      expect(result.metadata?.optimization).toBe('fallback')
      expect(result.warnings).toEqual(
        expect.arrayContaining([
          expect.objectContaining({
            type: 'quality',
            severity: 'high'
          })
        ])
      )
    })

    it('should include generation metadata', async () => {
      const request: GenerationRequest = {
        topics: [{ id: '1', topic: 'Test', content: 'Content' }],
        config: {
          paperSize: 'a4',
          orientation: 'portrait',
          columns: 1,
          fontSize: 'medium'
        }
      }

      mockPage.evaluate
        .mockResolvedValueOnce(undefined) // image loading
        .mockResolvedValueOnce(undefined) // page break optimization
        .mockResolvedValueOnce(1) // accurate page count

      const result = await pdfGenerator.generatePDF(request)

      expect(result.metadata).toBeDefined()
      expect(result.metadata?.fileSize).toBeGreaterThan(0)
      expect(result.metadata?.generationTime).toBeGreaterThan(0)
      expect(result.metadata?.optimization).toBe('enhanced')
    })
  })
})